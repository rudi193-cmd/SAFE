WARNING:root:Provider Ollama failed: HTTPConnectionPool(host='localhost', port=11434): Read timed out. (read timeout=120)
RouterResponse(content='```python\nimport httpx\nimport psutil\nfrom pathlib import Path\nfrom datetime import datetime\n\n# Server Start Time (initialized once when the module is loaded)\n_SERVER_START_TIME = datetime.now()\n\n# Define base paths relative to the script\'s directory.\n# Adjust these paths if your project structure differs or if the script is run from a different location.\n_BASE_DIR = Path(__file__).resolve().parent\n_GOVERNANCE_COMMITS_DIR = _BASE_DIR / "governance" / "commits"\n_INTAKE_BASE_DIR = _BASE_DIR / "intake"\n_TUNNEL_URL_FILE = _BASE_DIR / ".tunnel_url"\n\n# Ensure necessary directories exist for file system checks.\n# In a production environment, these directories would typically be managed by\n# the application setup or deployment process, not created on each status check.\n_GOVERNANCE_COMMITS_DIR.mkdir(parents=True, exist_ok=True)\nfor sub_dir in ["dump", "hold", "process", "route"]:\n    (_INTAKE_BASE_DIR / sub_dir).mkdir(parents=True, exist_ok=True)\n\n\nasync def get_system_status() -> dict:\n    """\n    Collects and returns various system status metrics as a dictionary.\n    This function is designed to be used as a FastAPI endpoint.\n    """\n    status = {\n        "ollama": {"running": False, "models": []},\n        "server": {"uptime_seconds": 0, "port": 8420},\n        "governance": {"pending_commits": 0, "last_ratification": None},\n        "intake": {"dump": 0, "hold": 0, "process": 0, "route": 0},\n        "engine": {"running": False},\n        "tunnel": {"url": None, "reachable": False}\n    }\n\n    # --- Ollama Check ---\n    try:\n        async with httpx.AsyncClient(timeout=5) as client:\n            response = await client.get("http://127.0.0.1:11434/api/tags")\n            response.raise_for_status()  # Raise an exception for HTTP errors (4xx or 5xx)\n            data = response.json()\n            status["ollama"]["running"] = True\n            status["ollama"]["models"] = [model["name"] for model in data.get("models", [])]\n    except (httpx.RequestError, ValueError, KeyError):\n        # Keep default values if Ollama is not reachable or response is invalid\n        pass\n\n    # --- Server Check ---\n    status["server"]["uptime_seconds"] = int((datetime.now() - _SERVER_START_TIME).total_seconds())\n\n    # --- Governance Check ---\n    try:\n        if _GOVERNANCE_COMMITS_DIR.is_dir():\n            pending_files = list(_GOVERNANCE_COMMITS_DIR.glob("*.pending"))\n            status["governance"]["pending_commits"] = len(pending_files)\n\n            # Determine last_ratification by finding the most recently modified non-pending file\n            all_files = [\n                f for f in _GOVERNANCE_COMMITS_DIR.iterdir()\n                if f.is_file() and not f.name.endswith(".pending")\n            ]\n            if all_files:\n                latest_file = max(all_files, key=lambda f: f.stat().st_mtime)\n                status["governance"]["last_ratification"] = datetime.fromtimestamp(latest_file.stat().st_mtime).isoformat()\n    except Exception:\n        # Keep default values if governance directory checks fail\n        pass\n\n    # --- Intake Check ---\n    for intake_type in ["dump", "hold", "process", "route"]:\n        path = _INTAKE_BASE_DIR / intake_type\n        try:\n            if path.is_dir():\n                status["intake"][intake_type] = len(list(path.iterdir()))\n        except Exception:\n            # Keep default value for this intake_type if check fails\n            pass\n\n    # --- Engine Check (kart process) ---\n    try:\n        for proc in psutil.process_iter([\'name\']):\n            if proc.info[\'name\'] == \'kart\':\n                status["engine"]["running"] = True\n                break\n    except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):\n        # Keep default value if psutil fails or process not found\n        pass\n\n    # --- Tunnel Check ---\n    try:\n        if _TUNNEL_URL_FILE.is_file():\n            tunnel_url = _TUNNEL_URL_FILE.read_text().strip()\n            if tunnel_url:\n                status["tunnel"]["url"] = tunnel_url\n                async with httpx.AsyncClient(timeout=5) as client:\n                    response = await client.head(tunnel_url)\n                    status["tunnel"]["reachable"] = response.is_success  # Check for 2xx status codes\n            else:\n                status["tunnel"]["url"] = None  # File exists but is empty\n    except (FileNotFoundError, httpx.RequestError, ValueError):\n        # Keep default values if tunnel file/url/reachability check fails\n        pass\n\n    return status\n```', provider='Google Gemini', tier='free')
